
			
shell脚本执行，如执行chdir.sh
# cat chdir.sh
#！/bin/bash
cd /tmp

1.明确声明脚本使用bash来解释的，这样脚本第一行的解释其将产生任何作用
[root@lenovo~ ]# bash chdir.sh

2.根据脚本第一行的解释器决定脚本该怎么执行，如果没有指定，默认使用bash解释
[root@lenovo~ ]#  ./chdir.sh

以上两种是
frok子进程

3.上述两种执行方法，都是fork子进程执行的，source不产生子进程
source chdir.sh 或  . chdir.sh

		[root@lenovo ~]# vim name.sh
		[root@lenovo ~]# bash name.sh
		[root@lenovo ~]# echo $name

		[root@lenovo ~]# chmod +x  name.sh
		[root@lenovo ~]# ./name.sh 
		[root@lenovo ~]# echo $name

		[root@lenovo ~]# source name.sh
		[root@lenovo ~]# echo $name
		zhangsan



			》》》进程的生命周期《《《

	僵尸进程没有任何可执行的代码，也不可能被调度	
	僵尸进程：
		1.消耗内存
		2.消耗PID号（有限的PID）

	可以试图杀死它的父进程


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

				》》》fork编程《《《

fork ()
派生子进程。
将0返回给子进程，将PID返回给父进程

	import os
	print("hello world")

	os.fork()
	print('你好'

	[root@lenovo pycharm]# python3 /root/桌面/5_张志刚/devops/Day1/pycharm/fork_1.py
	hello world
	你好
	你好



pythom中，绝大多数的函数值返回一次，os.fork将返回两次	
父进程返回子进程的PID，对于子进程，返回PID 0


	[root@lenovo pycharm]# python3 /root/桌面/5_张志刚/devops/Day1/pycharm/fork_1.py
	hello world
	12590					
	你好
	[root@lenovo pycharm]# 0
	你好


	import os
	print("hello world")

	pid = os.fork()			## 生成子进程，以下代码分别在父子进程中执行
	if pid:
	    print('父进程.......')		##os.fork()
	else:
	    print('子进程.......')
	print('你好')


	[root@lenovo pycharm]# python3 /root/桌面/5_张志刚/devops/Day1/pycharm/fork_2.py 
	hello world
	父进程.......
	你好
	子进程.......
	你好



	help(os.waitpid)
	posix模块内置函数waitpid的帮助:
	waitpid (pid,选项,/)
	等待给定子进程的完成。
	返回关于子进程的一组信息:
	(pid、状态)
	选项参数在Windows上被忽略。



waitpid()的返回值：如果子进程尚未结束则返回0，
否则返回子进程的PID 

		## 僵尸进程：
			子进程执行完代码之后，父进程没有执行完毕，此时这个子进程被称为僵尸进程

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

			
						》》》多线程《《《







GIL：全局解释器锁。某一时刻，值年呢个有一个线程交给python解释器，解释器把代码交给CPU


程序分类：
	计算密集型（CPU密集）应用：采用多进程可提升效率，多线程不能提升
	IO密集型应用：采用多进程，多线程可提升效率






^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
					》》》multiprocess《《《


启动两个进程 对此虚拟机来说有两个核心
	
	子进程0启动----37558			##子进程0，1同时启动
	子进程1启动----37559
	子进程0结束---37558,sleep1.001452s
	子进程1结束---37559,sleep1.001453s
	父进程结束


启动三个进程 
	父进程启动
	子进程0启动----37654	
	子进程1启动----37655
	子进程1结束---37655,sleep1.001444s	
	子进程2启动----37655			# 因为只有两个核心，在进程0结束之后，进程2才开始
	子进程0结束---37654,sleep3.003458s
	子进程2结束---37655,sleep3.002951s
	父进程结束




























